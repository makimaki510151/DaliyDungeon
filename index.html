<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ÊØéÊó•„ÉÄ„É≥„Ç∏„Éß„É≥ÔºàWebÁâàÔºâ</title>
    <style>
        :root {
            --bg: #f0f0f0;
            --dark: #646464;
            --light: #f4f4f4;
            --white: #ffffff;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Meiryo, sans-serif;
        }

        .wrap {
            display: grid;
            place-items: center;
            height: 100%;
            gap: 16px;
            padding: 16px;
            box-sizing: border-box;
        }

        canvas {
            background: #000;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .15);
            touch-action: none;
            width: 480px;
            height: 480px;
            max-width: 100%;
        }

        .hint {
            color: #444;
            font-size: 14px;
            text-align: center;
        }

        .btnbar {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            appearance: none;
            border: none;
            padding: 10px 14px;
            border-radius: 12px;
            background: #e8fff7;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 0, 0, .08) inset;
        }

        .btn:hover {
            filter: brightness(1.05);
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .volume {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .touchpad {
            display: grid;
            grid-template-areas:
                ". up ." "left center right" ". down .";
            gap: 10px;
            touch-action: none;
        }

        .tpbtn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: #dbeafe;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 18px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .tpbtn:active {
            background: #93c5fd;
        }

        /* „Çπ„Éû„ÉõÂØæÂøúÔºàÂπÖ600px‰ª•‰∏ã„ÅÆ„Å®„ÅçUI„ÇíÁ∏ÆÂ∞èÔºâ */
        @media (max-width: 600px) {
            canvas {
                width: 90vw;
                height: 90vw;
            }

            .tpbtn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 14px;
            }

            .hint {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <canvas id="game" width="480" height="480" aria-label="ÊØéÊó•„ÉÄ„É≥„Ç∏„Éß„É≥"></canvas>
        <div class="control-panel">
            <div class="btnbar">
                <button class="btn" id="startBtn">‚ñ∂ „ÉÄ„É≥„Ç∏„Éß„É≥„Å´ÊΩú„Çã</button>
                <button class="btn" id="restartBtn" style="display:none">‚Üª „ÇÇ„ÅÜ‰∏ÄÂ∫¶Âßã„ÇÅ„Çã</button>
            </div>
            <div class="volume">
                <label for="volRange">üîä Èü≥Èáè</label>
                <input type="range" id="volRange" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div class="touchpad">
                <button class="tpbtn" data-dir="up" style="grid-area:up">‚¨Ü</button>
                <button class="tpbtn" data-dir="left" style="grid-area:left">‚¨Ö</button>
                <button class="tpbtn" data-dir="right" style="grid-area:right">‚û°</button>
                <button class="tpbtn" data-dir="down" style="grid-area:down">‚¨á</button>
            </div>
        </div>
        <div class="hint">ÁßªÂãïÔºöWASD / ÊñπÂêë„Ç≠„Éº / „Çø„ÉÉ„ÉÅ„Éë„ÉÉ„Éâ„ÄÄ‚Ä¢„ÄÄÁõÆ„ÅÆÂâç„ÅÆÁ∑ë‰∏∏ = APÂõûÂæ© (+5~20)„ÄÄ‚Ä¢„ÄÄAP„Åå0„Åß„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</div>
    </div>

    <script>
        // ====== Âü∫Êú¨Ë®≠ÂÆö ======
        const SCREEN_W = 480, SCREEN_H = 480;
        const DUNGEON_W = 50, DUNGEON_H = 50;
        const TILE = 32;
        const VIEW = 7;
        const MAX_AP = 100;
        const AP_RECOVERY_MIN = 5, AP_RECOVERY_MAX = 20;
        let volume = 0.5;

        const COLORS = {
            WHITE: '#ffffff', BLACK: '#000000', ORANGE: '#ffa500', GREEN: '#00c800',
            RED: '#ff0000', LIGHT: '#f0f0f0', DARK: '#646464', MEDIUMSPRINGGREEN: '#00fa9a', AQUA: '#7fffd4'
        };

        // Êñ∞„Åó„ÅÑËâ≤„ÇíËøΩÂä†
        COLORS.PATH_FADE = '#cccccc'; // ÈÄö„Å£„ÅüÂæå„ÅÆ„Éû„Çπ„ÅÆËâ≤
        COLORS.STAIRS = '#663399';
        COLORS.FLAG_POLE = '#999999';
        COLORS.FLAG = '#ff9900';

        // ====== ‰π±Êï∞ÔºàÊó•Êõø„Çè„Çä„Ç∑„Éº„ÉâÔºâ ======
        function xmur3(str) { let h = 1779033703 ^ str.length; for (let i = 0; i < str.length; i++) { h = Math.imul(h ^ str.charCodeAt(i), 3432918353); h = h << 13 | h >>> 19; } return function () { h = Math.imul(h ^ (h >>> 16), 2246822507); h = Math.imul(h ^ (h >>> 13), 3266489909); return (h ^ (h >>> 16)) >>> 0; } }
        function mulberry32(a) { return function () { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
        function makeRNG(seedStr) { const seed = xmur3(seedStr)(); return mulberry32(seed); }

        // ====== „Ç™„Éº„Éá„Ç£„Ç™ ======
        const Audio = {
            ctx: null,
            ensure() { if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } },
            beep(freq = 440, dur = 0.1, type = 'sine', vol = 0.5, when = 0) { this.ensure(); const t = this.ctx.currentTime + when; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = type; o.frequency.value = freq; o.connect(g); g.connect(this.ctx.destination); g.gain.value = vol * volume; o.start(t); o.stop(t + dur); },
            noise(dur = 0.05, vol = 0.2) { this.ensure(); const sr = this.ctx.sampleRate; const len = Math.floor(sr * dur); const buffer = this.ctx.createBuffer(1, len, sr); const data = buffer.getChannelData(0); for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1; const src = this.ctx.createBufferSource(); const g = this.ctx.createGain(); src.buffer = buffer; src.connect(g); g.connect(this.ctx.destination); g.gain.value = vol * volume; src.start(); },
            move() { this.noise(0.05, 0.10); },
            heal() { this.beep(1200, 0.1, 'sine', 0.8); },
            goal() { [880, 1047, 1319, 1568].forEach((f, i) => this.beep(f, 0.1, 'sine', 0.5, i * 0.1)); },
            button() { this.noise(0.05, 0.2); }
        };

        // ====== „Ç≠„É£„É≥„Éê„ÇπÊ∫ñÂÇô ======
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ====== „Ç≤„Éº„É†Áä∂ÊÖã ======
        const STATE = { MENU: 'menu', PLAY: 'play', GAMEOVER: 'gameover' };
        let state = STATE.MENU;
        let dungeon = null;
        let startPos = null;
        let goalPos = null;
        let player = { y: 0, x: 0 };
        let ap = MAX_AP;
        let level = 1;
        let rng = makeRNG(seedFor(level));
        // ÁßªÂãï„ÅÆËªåË∑°„Çí‰øùÂ≠ò„Åô„ÇãÈÖçÂàó
        let path = [];
        // AP„Ç¢„Ç§„ÉÜ„É†„ÅÆÂõûÂæ©Èáè„Çí‰øùÂ≠ò„Åô„Çã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        let apItems = {};

        function seedFor(lv) { const d = new Date(); const yyyy = d.getFullYear(); const mm = String(d.getMonth() + 1).padStart(2, '0'); const dd = String(d.getDate()).padStart(2, '0'); return `${yyyy}${mm}${dd}${String(lv).padStart(2, '0')}`; }

        // ====== „ÉÄ„É≥„Ç∏„Éß„É≥ÁîüÊàê ======
        function generateDungeon(width, height, numRooms = 15, apItemCount = 20, seedStr = null) {
            rng = makeRNG(seedStr || 'seed');
            const WALL = '#', PATH = '.', START = 'S', GOAL = 'G', AP_ITEM = '+';
            const grid = Array.from({ length: height }, () => Array.from({ length: width }, () => WALL));
            const rooms = [];

            const randInt = (min, max) => Math.floor(rng() * (max - min + 1)) + min;

            for (let i = 0; i < numRooms; i++) {
                const rw = randInt(5, 10), rh = randInt(5, 10);
                const x = randInt(1, width - rw - 1), y = randInt(1, height - rh - 1);
                for (let yy = y; yy < y + rh; yy++) for (let xx = x; xx < x + rw; xx++) grid[yy][xx] = PATH;
                rooms.push({ x, y, w: rw, h: rh });
            }
            rooms.sort(() => rng() - 0.5);

            const carveLine = (x1, y1, x2, y2) => {
                if (rng() < 0.5) { while (x1 !== x2) { grid[y1][x1] = PATH; x1 += (x1 < x2 ? 1 : -1); } while (y1 !== y2) { grid[y1][x1] = PATH; y1 += (y1 < y2 ? 1 : -1); } }
                else { while (y1 !== y2) { grid[y1][x1] = PATH; y1 += (y1 < y2 ? 1 : -1); } while (x1 !== x2) { grid[y1][x1] = PATH; x1 += (x1 < x2 ? 1 : -1); } }
            };

            for (let i = 0; i < rooms.length - 1; i++) {
                const a = rooms[i], b = rooms[i + 1];
                const ax = a.x + (a.w >> 1), ay = a.y + (a.h >> 1);
                const bx = b.x + (b.w >> 1), by = b.y + (b.h >> 1);
                carveLine(ax, ay, bx, by);
            }

            const sRoom = rooms[0], gRoom = rooms[rooms.length - 1];
            const sy = sRoom.y + (sRoom.h >> 1), sx = sRoom.x + (sRoom.w >> 1);
            const gy = gRoom.y + (gRoom.h >> 1), gx = gRoom.x + (gRoom.w >> 1);
            grid[sy][sx] = START; grid[gy][gx] = GOAL;

            let placed = 0; let safety = 0;
            apItems = {}; // AP„Ç¢„Ç§„ÉÜ„É†„ÅÆÂõûÂæ©Èáè„ÇíÊ†ºÁ¥ç„Åô„Çã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂàùÊúüÂåñ
            while (placed < apItemCount && safety < 10000) {
                safety++;
                const y = randInt(1, height - 2), x = randInt(1, width - 2);
                if (grid[y][x] === PATH) {
                    grid[y][x] = AP_ITEM;
                    apItems[`${y},${x}`] = randInt(AP_RECOVERY_MIN, AP_RECOVERY_MAX);
                    placed++;
                }
            }

            return { grid, start: [sy, sx], goal: [gy, gx] };
        }

        // ====== ÁßªÂãïÂá¶ÁêÜ ======
        // Âà∂Âæ°„Éï„É©„Ç∞ÔºàÁ™Å„ÅçÊäú„Åë„ÉªÈï∑Êäº„Åó„ÅÆÂÜçÈñãÂà∂Âæ°Ôºâ
        let holdTimer = null;
        let repeatTimer = null;
        let isTransitioning = false; // ÈöéÂ±§ÈÅ∑Áßª‰∏≠„ÅØtrueÔºàÁßªÂãï„ÇíÁÑ°ÂäπÂåñÔºâ
        let ignorePressUntilRelease = false; // ÈÅ∑ÁßªÂæå„ÄÅÊåá„ÇíÈõ¢„Åô„Åæ„ÅßÊäº„ÅóÁõ¥„Åó„ÇíË¶ÅÊ±Ç„Åô„Çã

        function stopHold() {
            if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
            if (repeatTimer) { clearInterval(repeatTimer); repeatTimer = null; }
        }

        function moveByDir(dir) {
            if (dir === 'up') tryMove(0, -1);
            else if (dir === 'down') tryMove(0, 1);
            else if (dir === 'left') tryMove(-1, 0);
            else if (dir === 'right') tryMove(1, 0);
        }

        function startHold(dir) {
            // ÈÅ∑ÁßªÂá¶ÁêÜ‰∏≠„ÇÑ„ÄÅÈÅ∑ÁßªÂæå„Å´Êåá„ÇíÈõ¢„Åô„Åæ„Åß„ÅÆÈñì„ÅØÁÑ°ÂäπÂåñÔºàÂÜçÊäº„Åó„Çí‰øÉ„ÅôÔºâ
            if (isTransitioning || ignorePressUntilRelease) return;

            // „Åô„Åê„Å´1ÂõûÁßªÂãï
            moveByDir(dir);

            // Â∞ë„ÅóÈÅÖÂª∂„Åó„ÅüÂæå„Å´ÈÄ£Á∂öÁßªÂãïÈñãÂßã
            holdTimer = setTimeout(() => {
                // ÂÜç„ÉÅ„Çß„ÉÉ„ÇØ
                if (isTransitioning) { stopHold(); return; }
                repeatTimer = setInterval(() => {
                    if (!isTransitioning) moveByDir(dir);
                }, 120); // ÈÄ£ÊâìÈñìÈöîÔºàmsÔºâ
            }, 450); // Èï∑Êäº„ÅóÈñãÂßãÈÅÖÂª∂ÔºàmsÔºâ
        }

        function tryMove(dx, dy) {
            if (state !== STATE.PLAY) return;
            if (isTransitioning) return; // ÈÅ∑Áßª‰∏≠„ÅØÁÑ°ÂäπÂåñ

            const nx = player.x + dx;
            const ny = player.y + dy;
            if (nx < 0 || nx >= DUNGEON_W || ny < 0 || ny >= DUNGEON_H) return;
            if (dungeon[ny][nx] === '#') return;

            // === „Ç¥„Éº„É´„Å∏ÂÖ•„ÇãÂá¶ÁêÜÔºàÂÖà„Å´Âà§ÂÆöÔºâ ===
            if (ny === goalPos[0] && nx === goalPos[1]) {
                // „Éó„É¨„Ç§„É§„Éº„Çí„Ç¥„Éº„É´‰ΩçÁΩÆ„Å´ÁßªÂãïÔºàË¶ã„ÅüÁõÆ„Å®„Åó„Å¶Ôºâ
                player.x = nx;
                player.y = ny;
                ap -= 1;
                Audio.goal();

                // Èï∑Êäº„Åó„ÇíÂç≥Â∫ß„Å´Ëß£Èô§„Åó„Å¶„ÄÅ‰ª•Èôç„ÅØÂÜçÊäº„Åó„ÅåÂøÖË¶Å„Å´„Å™„Çã„Çà„ÅÜ„Å´„Åô„Çã
                stopHold();
                ignorePressUntilRelease = true;
                isTransitioning = true;

                // Â∞ë„ÅóÊºîÂá∫„ÅÆÂæå„Å´Ê¨°Èöé„Å∏ÁßªË°å
                setTimeout(() => {
                    nextLevel();
                    // Ê¨°Èöé„ÅßÂç≥Âãï„Åã„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã„Åü„ÇÅ„ÄÅignorePressUntilRelease „ÅØÊåá„ÅåÈõ¢„Åï„Çå„Çã„Åæ„Åß true „ÅÆ„Åæ„Åæ„Å´„Åô„Çã
                    isTransitioning = false;
                }, 250);
                return; // Á™Å„ÅçÊäú„ÅëÈò≤Ê≠¢Ôºö„Åì„Åì„ÅßÂá¶ÁêÜÁµÇ‰∫Ü
            }

            // === ÈÄöÂ∏∏ÁßªÂãï ===
            // ËªåË∑°„Çí‰øùÂ≠ò
            path.push({ x: player.x, y: player.y });
            player.x = nx;
            player.y = ny;
            ap -= 1;
            Audio.move();

            if (dungeon[ny][nx] === '+') {
                const recoveryAmount = apItems[`${ny},${nx}`];
                if (recoveryAmount) {
                    ap = Math.min(MAX_AP, ap + recoveryAmount);
                    dungeon[ny][nx] = '.';
                    delete apItems[`${ny},${nx}`]; // ÂõûÂæ©Èáè„ÇíÂâäÈô§
                    Audio.heal();
                }
            }

            if (ap <= 0) {
                changeState(STATE.GAMEOVER);
                stopHold();
                return;
            }
        }

        // ====== ÂÖ•ÂäõÔºà„Ç≠„Éº„Éú„Éº„ÉâÔºâ ======
        window.addEventListener('keydown', (e) => {
            if (['w', 'W', 'ArrowUp'].includes(e.key)) tryMove(0, -1);
            else if (['s', 'S', 'ArrowDown'].includes(e.key)) tryMove(0, 1);
            else if (['a', 'A', 'ArrowLeft'].includes(e.key)) tryMove(-1, 0);
            else if (['d', 'D', 'ArrowRight'].includes(e.key)) tryMove(1, 0);
        });

        // ====== ÂçÅÂ≠óUIÔºàpointer „Ç§„Éô„É≥„Éà„Çí‰ΩøÁî®Ôºâ ======
        document.querySelectorAll('.tpbtn').forEach(btn => {
            const dir = btn.dataset.dir;

            // pointerdown „ÅßÈï∑Êäº„ÅóÈñãÂßãÔºà„Çø„ÉÉ„ÉÅ„Éª„Éû„Ç¶„Çπ„Å®„ÇÇ„Å´ÊúâÂäπÔºâ
            btn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                // pointerdown „ÅåÁô∫Áîü„Åó„Å¶„ÇÇ„ÄÅÈÅ∑ÁßªÂæå„Å´Êåá„ÇíÈõ¢„Åô„Åæ„Åß„ÅØÂèçÂøú„Åï„Åõ„Å™„ÅÑ
                if (ignorePressUntilRelease) return;
                startHold(dir);
            });

            // pointerup / pointercancel / pointerleave „ÅßËß£Èô§
            btn.addEventListener('pointerup', () => {
                stopHold();
            });
            btn.addEventListener('pointercancel', () => {
                stopHold();
                // pointercancel „ÅØÊåá„ÅåÈõ¢„Çå„ÅüÁõ∏ÂΩì„Å®„Åø„Å™„Åó„Å¶ÂÜçÈñãÂèØËÉΩ„Å´„Åô„Çã
                ignorePressUntilRelease = false;
            });
            btn.addEventListener('pointerleave', () => {
                stopHold();
            });
        });

        // „Ç∞„É≠„Éº„Éê„É´„Å´ pointerup „ÇíÊãæ„Å£„Å¶„ÄåÊåá„ÇíÈõ¢„Åó„Åü„Äç„Åì„Å®„ÇíÊ§úÁü• -> ÂÜçÊäº„ÅóÂèØËÉΩ„Å´„Åô„Çã
        window.addEventListener('pointerup', () => {
            stopHold();
            ignorePressUntilRelease = false;
        });
        window.addEventListener('pointercancel', () => {
            stopHold();
            ignorePressUntilRelease = false;
        });

        // Èü≥Èáè„Éê„Éº
        document.getElementById('volRange').addEventListener('input', (e) => {
            volume = parseFloat(e.target.value);
        });

        // ====== ÁîªÈù¢ÈÅ∑Áßª ======
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        startBtn.addEventListener('click', () => { Audio.button(); beginGame(); });
        restartBtn.addEventListener('click', () => { Audio.button(); resetGame(); beginGame(); });

        function changeState(s) { state = s; restartBtn.style.display = (s === STATE.GAMEOVER) ? 'inline-block' : 'none'; }

        function beginGame() {
            level = (state === STATE.GAMEOVER) ? 1 : level;
            const seed = seedFor(level);
            const gen = generateDungeon(DUNGEON_W, DUNGEON_H, 15, 10, seed);
            dungeon = gen.grid; startPos = gen.start; goalPos = gen.goal;
            player.y = startPos[0]; player.x = startPos[1];
            if (state !== STATE.GAMEOVER) ap = MAX_AP;
            changeState(STATE.PLAY);
            // ÂàùÊúüÂåñÔºöÊäº„Åó„Å£„Å±„Å™„Åó„Ç¨„Éº„ÉâËß£Èô§
            stopHold();
            ignorePressUntilRelease = false;
            isTransitioning = false;
            path = []; // „Ç≤„Éº„É†ÈñãÂßãÊôÇ„Å´ËªåË∑°„Çí„É™„Çª„ÉÉ„Éà
        }

        function nextLevel() {
            level += 1;
            const seed = seedFor(level);
            const gen = generateDungeon(DUNGEON_W, DUNGEON_H, 15, 10, seed);
            dungeon = gen.grid; startPos = gen.start; goalPos = gen.goal;
            player.y = startPos[0]; player.x = startPos[1];
            // Ê¨°Èöé„Å´Êù•„ÅüÁõ¥Âæå„ÅØÊäº„ÅóÁõ¥„Åó„ÇíË¶ÅÊ±Ç„Åô„ÇãÔºàignore „ÅØÈÅ∑ÁßªÂá¶ÁêÜ„ÅßÂà∂Âæ°Ôºâ
            stopHold();
            path = []; // ÈöéÂ±§ÈÅ∑ÁßªÊôÇ„Å´ËªåË∑°„Çí„É™„Çª„ÉÉ„Éà
        }

        function resetGame() { level = 1; ap = MAX_AP; }

        // ====== ÊèèÁîª ======
        function drawRect(x, y, w, h, fill) { ctx.fillStyle = fill; ctx.fillRect(x, y, w, h); }
        function drawText(text, x, y, size = 30, color = '#000', align = 'center') { ctx.fillStyle = color; ctx.font = `${size}px sans-serif`; ctx.textAlign = align; ctx.textBaseline = 'middle'; ctx.fillText(text, x, y); }

        function render() {
            ctx.clearRect(0, 0, SCREEN_W, SCREEN_H);

            if (state === STATE.MENU) {
                drawRect(0, 0, SCREEN_W, SCREEN_H, COLORS.LIGHT);
                drawText('ÊØéÊó•„ÉÄ„É≥„Ç∏„Éß„É≥', SCREEN_W / 2, 200, 56, COLORS.BLACK);
                return;
            }

            if (state === STATE.GAMEOVER) {
                drawRect(0, 0, SCREEN_W, SCREEN_H, COLORS.LIGHT);
                drawText('GAME OVER', SCREEN_W / 2, 150, 56, COLORS.RED);
                drawText(`ÊΩú„Å£„ÅüÈöéÂ±§: ${level}`, SCREEN_W / 2, 250, 24, COLORS.BLACK);
                return;
            }

            drawRect(0, 0, SCREEN_W, SCREEN_H, COLORS.BLACK);

            const startX = Math.max(0, player.x - VIEW);
            const endX = Math.min(DUNGEON_W, player.x + VIEW + 1);
            const startY = Math.max(0, player.y - VIEW);
            const endY = Math.min(DUNGEON_H, player.y + VIEW + 1);

            // „Åæ„Åö„ÄÅ„Çø„Ç§„É´„Å®„Ç∞„É™„ÉÉ„Éâ„Çí‰∏ÄÁ∑í„Å´ÊèèÁîª
            ctx.setLineDash([4, 4]);
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const screenX = (x - player.x + VIEW) * TILE;
                    const screenY = (y - player.y + VIEW) * TILE;
                    const tile = dungeon[y][x];

                    // „Çø„Ç§„É´„ÇíÂ°ó„Çä„Å§„Å∂„Åó
                    if (tile === '#') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.DARK);
                    } else if (tile === '.') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.LIGHT);
                    } else if (tile === '+') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.LIGHT);
                        ctx.beginPath();
                        ctx.fillStyle = COLORS.GREEN;
                        ctx.arc(screenX + TILE / 2, screenY + TILE / 2, TILE / 4, 0, Math.PI * 2);
                        ctx.fill();

                        // APÂõûÂæ©Èáè„ÇíÊèèÁîª
                        const recoveryAmount = apItems[`${y},${x}`];
                        if (recoveryAmount) {
                            ctx.fillStyle = COLORS.WHITE;
                            ctx.font = '10px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(recoveryAmount, screenX + TILE / 2, screenY + TILE / 2);
                        }

                    } else if (tile === 'G') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.LIGHT);
                        // Êóó„ÇíÊèèÁîª
                        const flagPoleX = screenX + TILE * 0.7;
                        const flagPoleY = screenY + TILE * 0.2;
                        const flagPoleHeight = TILE * 0.6;
                        const flagWidth = TILE * 0.4;
                        const flagHeight = TILE * 0.3;

                        // ÊóóÁ´ø
                        drawRect(flagPoleX, flagPoleY, 2, flagPoleHeight, COLORS.FLAG_POLE);

                        // Êóó
                        ctx.beginPath();
                        ctx.fillStyle = COLORS.FLAG;
                        ctx.moveTo(flagPoleX, flagPoleY);
                        ctx.lineTo(flagPoleX - flagWidth, flagPoleY + flagHeight * 0.5);
                        ctx.lineTo(flagPoleX, flagPoleY + flagHeight);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // „Çø„Ç§„É´„ÅÆËâ≤„Å´Âøú„Åò„Å¶„Ç∞„É™„ÉÉ„Éâ„ÅÆËâ≤„ÇíÂ§âÊõ¥
                    if (tile === '#') {
                        ctx.strokeStyle = '#333333'; // Â£ÅÁî®„ÅÆÊöó„ÅÑËâ≤
                    } else {
                        ctx.strokeStyle = '#e0e0e0'; // ÈÄöË∑ØÁî®„ÅÆÊòé„Çã„ÅÑËâ≤
                    }
                    ctx.strokeRect(screenX, screenY, TILE, TILE);
                }
            }
            ctx.setLineDash([]); // ÁÇπÁ∑öË®≠ÂÆö„Çí„É™„Çª„ÉÉ„Éà

            // „Åù„ÅÆÂæå„ÄÅËªåË∑°„Å®„Éó„É¨„Ç§„É§„Éº„ÄÅ„Åù„ÅÆ‰ªñ„Çí‰∏äÊõ∏„ÅçÊèèÁîª
            drawPath();

            // „Éó„É¨„Ç§„É§„Éº
            const px = VIEW * TILE, py = VIEW * TILE;
            drawText('P', px + TILE / 2, py + TILE / 2, 24, COLORS.RED);

            // „Çπ„Çø„Éº„ÉàÂú∞ÁÇπ
            if (player.y === startPos[0] && player.x === startPos[1]) {
                drawText('S', px + TILE / 2, py + TILE / 2, 24, COLORS.GREEN);
            } else {
                const sx = (startPos[1] - player.x + VIEW) * TILE;
                const sy = (startPos[0] - player.y + VIEW) * TILE;
                drawText('S', sx + TILE / 2, sy + TILE / 2, 24, COLORS.GREEN);
            }

            // AP„Éê„Éº
            const barW = 120, barH = 16, barX = SCREEN_W - barW - 16, barY = 16;
            drawRect(barX, barY, barW, barH, COLORS.DARK);
            const ratio = Math.max(0, ap) / MAX_AP;
            drawRect(barX, barY, barW * ratio, barH, COLORS.GREEN);
            drawText(`AP: ${ap}/${MAX_AP}`, barX - 56, barY + barH / 2, 13, COLORS.WHITE, 'right');
        }

        // Êñ∞„Åó„ÅÑÊèèÁîªÈñ¢Êï∞ÔºöËªåË∑°
        function drawPath() {
            for (const p of path) {
                const screenX = (p.x - player.x + VIEW) * TILE;
                const screenY = (p.y - player.y + VIEW) * TILE;
                const tile = dungeon[p.y][p.x];
                // ÁîªÈù¢ÁØÑÂõ≤ÂÜÖ„Å´„ÅÇ„Çå„Å∞ÊèèÁîª
                if (screenX >= 0 && screenX < SCREEN_W && screenY >= 0 && screenY < SCREEN_H) {
                    // „Ç¥„Éº„É´„Å®„Çπ„Çø„Éº„ÉàÂú∞ÁÇπ„ÅØËªåË∑°„ÇíÊèèÁîª„Åó„Å™„ÅÑ
                    if (tile !== 'G' && tile !== 'S') {
                        ctx.beginPath();
                        ctx.fillStyle = '#dddddd'; // „Åï„Çâ„Å´ËñÑ„ÅÑËâ≤„Å´Â§âÊõ¥
                        ctx.arc(screenX + TILE / 2, screenY + TILE / 2, TILE / 8, 0, Math.PI * 2); // Â∞è„Åï„Å™ÁÇπ„ÇíÊèèÁîª
                        ctx.fill();
                    }
                }
            }
        }

        // ====== „É°„Ç§„É≥„É´„Éº„Éó ======
        function loop() { render(); requestAnimationFrame(loop); }
        loop();

        // ÂàùÊúüUI
        function showMenu() { changeState(STATE.MENU); }
        showMenu();
    </script>
</body>

</html>