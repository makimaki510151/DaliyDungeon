<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>æ¯æ—¥ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼ˆWebç‰ˆï¼‰</title>
    <style>
        :root {
            --bg: #f0f0f0;
            --dark: #646464;
            --light: #f4f4f4;
            --white: #ffffff;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Meiryo, sans-serif;
        }

        .wrap {
            display: grid;
            place-items: center;
            height: 100%;
            gap: 16px;
            padding: 16px;
            box-sizing: border-box;
        }

        canvas {
            background: #000;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .15);
            touch-action: none;
            width: 480px;
            height: 480px;
            max-width: 100%;
        }

        .hint {
            color: #444;
            font-size: 14px;
            text-align: center;
        }

        .btnbar {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            appearance: none;
            border: none;
            padding: 10px 14px;
            border-radius: 12px;
            background: #e8fff7;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 0, 0, .08) inset;
        }

        .btn:hover {
            filter: brightness(1.05);
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .volume {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .touchpad {
            display: grid;
            grid-template-areas:
                ". up ." "left center right" ". down .";
            gap: 10px;
            touch-action: none;
        }

        .tpbtn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: #dbeafe;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 18px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .tpbtn:active {
            background: #93c5fd;
        }

        /* ã‚¹ãƒãƒ›å¯¾å¿œï¼ˆå¹…600pxä»¥ä¸‹ã®ã¨ãUIã‚’ç¸®å°ï¼‰ */
        @media (max-width: 600px) {
            canvas {
                width: 90vw;
                height: 90vw;
            }

            .tpbtn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 14px;
            }

            .hint {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <canvas id="game" width="480" height="480" aria-label="æ¯æ—¥ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³"></canvas>
        <div class="control-panel">
            <div class="btnbar">
                <button class="btn" id="startBtn">â–¶ ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã«æ½œã‚‹</button>
                <button class="btn" id="restartBtn" style="display:none">â†» ã‚‚ã†ä¸€åº¦å§‹ã‚ã‚‹</button>
            </div>
            <div class="volume">
                <label for="volRange">ğŸ”Š éŸ³é‡</label>
                <input type="range" id="volRange" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div class="touchpad">
                <button class="tpbtn" data-dir="up" style="grid-area:up">â¬†</button>
                <button class="tpbtn" data-dir="left" style="grid-area:left">â¬…</button>
                <button class="tpbtn" data-dir="right" style="grid-area:right">â¡</button>
                <button class="tpbtn" data-dir="down" style="grid-area:down">â¬‡</button>
            </div>
        </div>
        <div class="hint">ç§»å‹•ï¼šWASD / æ–¹å‘ã‚­ãƒ¼ / ã‚¿ãƒƒãƒãƒ‘ãƒƒãƒ‰ã€€â€¢ã€€ç›®ã®å‰ã®ç·‘ä¸¸ = APå›å¾© (+5~20)ã€€â€¢ã€€APãŒ0ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
    </div>

    <script>
        // ====== åŸºæœ¬è¨­å®š ======
        const SCREEN_W = 480, SCREEN_H = 480;
        const DUNGEON_W = 50, DUNGEON_H = 50;
        const TILE = 32;
        const VIEW = 7;
        const MAX_AP = 100;
        const AP_RECOVERY_MIN = 5, AP_RECOVERY_MAX = 20;
        let volume = 0.5;

        const COLORS = {
            WHITE: '#ffffff', BLACK: '#000000', ORANGE: '#ffa500', GREEN: '#00c800',
            RED: '#ff0000', LIGHT: '#f0f0f0', DARK: '#646464', MEDIUMSPRINGGREEN: '#00fa9a', AQUA: '#7fffd4'
        };

        // æ–°ã—ã„è‰²ã‚’è¿½åŠ 
        COLORS.PATH_FADE = '#cccccc'; // é€šã£ãŸå¾Œã®ãƒã‚¹ã®è‰²
        COLORS.STAIRS = '#663399';
        COLORS.FLAG_POLE = '#999999';
        COLORS.FLAG = '#ff9900';

        // ====== ä¹±æ•°ï¼ˆæ—¥æ›¿ã‚ã‚Šã‚·ãƒ¼ãƒ‰ï¼‰ ======
        function xmur3(str) { let h = 1779033703 ^ str.length; for (let i = 0; i < str.length; i++) { h = Math.imul(h ^ str.charCodeAt(i), 3432918353); h = h << 13 | h >>> 19; } return function () { h = Math.imul(h ^ (h >>> 16), 2246822507); h = Math.imul(h ^ (h >>> 13), 3266489909); return (h ^ (h >>> 16)) >>> 0; } }
        function mulberry32(a) { return function () { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
        function makeRNG(seedStr) { const seed = xmur3(seedStr)(); return mulberry32(seed); }

        // ====== ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª ======
        const Audio = {
            ctx: null,
            ensure() { if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } },
            beep(freq = 440, dur = 0.1, type = 'sine', vol = 0.5, when = 0) { this.ensure(); const t = this.ctx.currentTime + when; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = type; o.frequency.value = freq; o.connect(g); g.connect(this.ctx.destination); g.gain.value = vol * volume; o.start(t); o.stop(t + dur); },
            noise(dur = 0.05, vol = 0.2) { this.ensure(); const sr = this.ctx.sampleRate; const len = Math.floor(sr * dur); const buffer = this.ctx.createBuffer(1, len, sr); const data = buffer.getChannelData(0); for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1; const src = this.ctx.createBufferSource(); const g = this.ctx.createGain(); src.buffer = buffer; src.connect(g); g.connect(this.ctx.destination); g.gain.value = vol * volume; src.start(); },
            move() { this.noise(0.05, 0.10); },
            heal() { this.beep(1200, 0.1, 'sine', 0.8); },
            goal() { [880, 1047, 1319, 1568].forEach((f, i) => this.beep(f, 0.1, 'sine', 0.5, i * 0.1)); },
            button() { this.noise(0.05, 0.2); }
        };

        // ====== ã‚­ãƒ£ãƒ³ãƒã‚¹æº–å‚™ ======
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
        const STATE = { MENU: 'menu', PLAY: 'play', GAMEOVER: 'gameover' };
        let state = STATE.MENU;
        let dungeon = null;
        let startPos = null;
        let goalPos = null;
        let player = { y: 0, x: 0 };
        let ap = MAX_AP;
        let level = 1;
        let rng = makeRNG(seedFor(level));
        // ç§»å‹•ã®è»Œè·¡ã‚’ä¿å­˜ã™ã‚‹é…åˆ—
        let path = [];
        // APã‚¢ã‚¤ãƒ†ãƒ ã®å›å¾©é‡ã‚’ä¿å­˜ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        let apItems = {};

        function seedFor(lv) { const d = new Date(); const yyyy = d.getFullYear(); const mm = String(d.getMonth() + 1).padStart(2, '0'); const dd = String(d.getDate()).padStart(2, '0'); return `${yyyy}${mm}${dd}${String(lv).padStart(2, '0')}`; }

        // ====== ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ç”Ÿæˆ ======
        function generateDungeon(width, height, numRooms = 15, apItemCount = 20, seedStr = null) {
            rng = makeRNG(seedStr || 'seed');
            const WALL = '#', PATH = '.', START = 'S', GOAL = 'G', AP_ITEM = '+';
            const grid = Array.from({ length: height }, () => Array.from({ length: width }, () => WALL));
            const rooms = [];

            const randInt = (min, max) => Math.floor(rng() * (max - min + 1)) + min;

            for (let i = 0; i < numRooms; i++) {
                const rw = randInt(5, 10), rh = randInt(5, 10);
                const x = randInt(1, width - rw - 1), y = randInt(1, height - rh - 1);
                for (let yy = y; yy < y + rh; yy++) for (let xx = x; xx < x + rw; xx++) grid[yy][xx] = PATH;
                rooms.push({ x, y, w: rw, h: rh });
            }
            rooms.sort(() => rng() - 0.5);

            const carveLine = (x1, y1, x2, y2) => {
                if (rng() < 0.5) { while (x1 !== x2) { grid[y1][x1] = PATH; x1 += (x1 < x2 ? 1 : -1); } while (y1 !== y2) { grid[y1][x1] = PATH; y1 += (y1 < y2 ? 1 : -1); } }
                else { while (y1 !== y2) { grid[y1][x1] = PATH; y1 += (y1 < y2 ? 1 : -1); } while (x1 !== x2) { grid[y1][x1] = PATH; x1 += (x1 < x2 ? 1 : -1); } }
            };

            for (let i = 0; i < rooms.length - 1; i++) {
                const a = rooms[i], b = rooms[i + 1];
                const ax = a.x + (a.w >> 1), ay = a.y + (a.h >> 1);
                const bx = b.x + (b.w >> 1), by = b.y + (b.h >> 1);
                carveLine(ax, ay, bx, by);
            }

            const sRoom = rooms[0], gRoom = rooms[rooms.length - 1];
            const sy = sRoom.y + (sRoom.h >> 1), sx = sRoom.x + (sRoom.w >> 1);
            const gy = gRoom.y + (gRoom.h >> 1), gx = gRoom.x + (gRoom.w >> 1);
            grid[sy][sx] = START; grid[gy][gx] = GOAL;

            let placed = 0; let safety = 0;
            apItems = {}; // APã‚¢ã‚¤ãƒ†ãƒ ã®å›å¾©é‡ã‚’æ ¼ç´ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆæœŸåŒ–
            while (placed < apItemCount && safety < 10000) {
                safety++;
                const y = randInt(1, height - 2), x = randInt(1, width - 2);
                if (grid[y][x] === PATH) {
                    grid[y][x] = AP_ITEM;
                    apItems[`${y},${x}`] = randInt(AP_RECOVERY_MIN, AP_RECOVERY_MAX);
                    placed++;
                }
            }

            return { grid, start: [sy, sx], goal: [gy, gx] };
        }

        // ====== ç§»å‹•å‡¦ç† ======
        // åˆ¶å¾¡ãƒ•ãƒ©ã‚°ï¼ˆçªãæŠœã‘ãƒ»é•·æŠ¼ã—ã®å†é–‹åˆ¶å¾¡ï¼‰
        let holdTimer = null;
        let repeatTimer = null;
        let isTransitioning = false; // éšå±¤é·ç§»ä¸­ã¯trueï¼ˆç§»å‹•ã‚’ç„¡åŠ¹åŒ–ï¼‰
        let ignorePressUntilRelease = false; // é·ç§»å¾Œã€æŒ‡ã‚’é›¢ã™ã¾ã§æŠ¼ã—ç›´ã—ã‚’è¦æ±‚ã™ã‚‹

        function stopHold() {
            if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
            if (repeatTimer) { clearInterval(repeatTimer); repeatTimer = null; }
        }

        function moveByDir(dir) {
            if (dir === 'up') tryMove(0, -1);
            else if (dir === 'down') tryMove(0, 1);
            else if (dir === 'left') tryMove(-1, 0);
            else if (dir === 'right') tryMove(1, 0);
        }

        function startHold(dir) {
            // é·ç§»å‡¦ç†ä¸­ã‚„ã€é·ç§»å¾Œã«æŒ‡ã‚’é›¢ã™ã¾ã§ã®é–“ã¯ç„¡åŠ¹åŒ–ï¼ˆå†æŠ¼ã—ã‚’ä¿ƒã™ï¼‰
            if (isTransitioning || ignorePressUntilRelease) return;

            // ã™ãã«1å›ç§»å‹•
            moveByDir(dir);

            // å°‘ã—é…å»¶ã—ãŸå¾Œã«é€£ç¶šç§»å‹•é–‹å§‹
            holdTimer = setTimeout(() => {
                // å†ãƒã‚§ãƒƒã‚¯
                if (isTransitioning) { stopHold(); return; }
                repeatTimer = setInterval(() => {
                    if (!isTransitioning) moveByDir(dir);
                }, 120); // é€£æ‰“é–“éš”ï¼ˆmsï¼‰
            }, 450); // é•·æŠ¼ã—é–‹å§‹é…å»¶ï¼ˆmsï¼‰
        }

        function tryMove(dx, dy) {
            if (state !== STATE.PLAY) return;
            if (isTransitioning) return; // é·ç§»ä¸­ã¯ç„¡åŠ¹åŒ–

            const nx = player.x + dx;
            const ny = player.y + dy;
            if (nx < 0 || nx >= DUNGEON_W || ny < 0 || ny >= DUNGEON_H) return;
            if (dungeon[ny][nx] === '#') return;

            // === ã‚´ãƒ¼ãƒ«ã¸å…¥ã‚‹å‡¦ç†ï¼ˆå…ˆã«åˆ¤å®šï¼‰ ===
            if (ny === goalPos[0] && nx === goalPos[1]) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚´ãƒ¼ãƒ«ä½ç½®ã«ç§»å‹•ï¼ˆè¦‹ãŸç›®ã¨ã—ã¦ï¼‰
                player.x = nx;
                player.y = ny;
                ap -= 1;
                Audio.goal();

                // é•·æŠ¼ã—ã‚’å³åº§ã«è§£é™¤ã—ã¦ã€ä»¥é™ã¯å†æŠ¼ã—ãŒå¿…è¦ã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹
                stopHold();
                ignorePressUntilRelease = true;
                isTransitioning = true;

                // å°‘ã—æ¼”å‡ºã®å¾Œã«æ¬¡éšã¸ç§»è¡Œ
                setTimeout(() => {
                    nextLevel();
                    // æ¬¡éšã§å³å‹•ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ignorePressUntilRelease ã¯æŒ‡ãŒé›¢ã•ã‚Œã‚‹ã¾ã§ true ã®ã¾ã¾ã«ã™ã‚‹
                    isTransitioning = false;
                }, 250);
                return; // çªãæŠœã‘é˜²æ­¢ï¼šã“ã“ã§å‡¦ç†çµ‚äº†
            }

            // === é€šå¸¸ç§»å‹• ===
            // è»Œè·¡ã‚’ä¿å­˜
            path.push({ x: player.x, y: player.y });
            player.x = nx;
            player.y = ny;
            ap -= 1;
            Audio.move();

            if (dungeon[ny][nx] === '+') {
                const recoveryAmount = apItems[`${ny},${nx}`];
                if (recoveryAmount) {
                    ap = Math.min(MAX_AP, ap + recoveryAmount);
                    dungeon[ny][nx] = '.';
                    delete apItems[`${ny},${nx}`]; // å›å¾©é‡ã‚’å‰Šé™¤
                    Audio.heal();
                }
            }

            if (ap <= 0) {
                changeState(STATE.GAMEOVER);
                stopHold();
                return;
            }
        }

        // ====== å…¥åŠ›ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼‰ ======
        window.addEventListener('keydown', (e) => {
            if (['w', 'W', 'ArrowUp'].includes(e.key)) tryMove(0, -1);
            else if (['s', 'S', 'ArrowDown'].includes(e.key)) tryMove(0, 1);
            else if (['a', 'A', 'ArrowLeft'].includes(e.key)) tryMove(-1, 0);
            else if (['d', 'D', 'ArrowRight'].includes(e.key)) tryMove(1, 0);
        });

        // ====== åå­—UIï¼ˆpointer ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ç”¨ï¼‰ ======
        document.querySelectorAll('.tpbtn').forEach(btn => {
            const dir = btn.dataset.dir;

            // pointerdown ã§é•·æŠ¼ã—é–‹å§‹ï¼ˆã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹ã¨ã‚‚ã«æœ‰åŠ¹ï¼‰
            btn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                // pointerdown ãŒç™ºç”Ÿã—ã¦ã‚‚ã€é·ç§»å¾Œã«æŒ‡ã‚’é›¢ã™ã¾ã§ã¯åå¿œã•ã›ãªã„
                if (ignorePressUntilRelease) return;
                startHold(dir);
            });

            // pointerup / pointercancel / pointerleave ã§è§£é™¤
            btn.addEventListener('pointerup', () => {
                stopHold();
            });
            btn.addEventListener('pointercancel', () => {
                stopHold();
                // pointercancel ã¯æŒ‡ãŒé›¢ã‚ŒãŸç›¸å½“ã¨ã¿ãªã—ã¦å†é–‹å¯èƒ½ã«ã™ã‚‹
                ignorePressUntilRelease = false;
            });
            btn.addEventListener('pointerleave', () => {
                stopHold();
            });
        });

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã« pointerup ã‚’æ‹¾ã£ã¦ã€ŒæŒ‡ã‚’é›¢ã—ãŸã€ã“ã¨ã‚’æ¤œçŸ¥ -> å†æŠ¼ã—å¯èƒ½ã«ã™ã‚‹
        window.addEventListener('pointerup', () => {
            stopHold();
            ignorePressUntilRelease = false;
        });
        window.addEventListener('pointercancel', () => {
            stopHold();
            ignorePressUntilRelease = false;
        });

        // éŸ³é‡ãƒãƒ¼
        document.getElementById('volRange').addEventListener('input', (e) => {
            volume = parseFloat(e.target.value);
        });

        // ====== ç”»é¢é·ç§» ======
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        startBtn.addEventListener('click', () => { Audio.button(); beginGame(); });
        restartBtn.addEventListener('click', () => { Audio.button(); resetGame(); beginGame(); });

        function changeState(s) { state = s; restartBtn.style.display = (s === STATE.GAMEOVER) ? 'inline-block' : 'none'; }

        function beginGame() {
            level = (state === STATE.GAMEOVER) ? 1 : level;
            const seed = seedFor(level);
            const gen = generateDungeon(DUNGEON_W, DUNGEON_H, 15, 10, seed);
            dungeon = gen.grid; startPos = gen.start; goalPos = gen.goal;
            player.y = startPos[0]; player.x = startPos[1];
            if (state !== STATE.GAMEOVER) ap = MAX_AP;
            changeState(STATE.PLAY);
            // åˆæœŸåŒ–ï¼šæŠ¼ã—ã£ã±ãªã—ã‚¬ãƒ¼ãƒ‰è§£é™¤
            stopHold();
            ignorePressUntilRelease = false;
            isTransitioning = false;
            path = []; // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«è»Œè·¡ã‚’ãƒªã‚»ãƒƒãƒˆ
        }

        function nextLevel() {
            level += 1;
            const seed = seedFor(level);
            const gen = generateDungeon(DUNGEON_W, DUNGEON_H, 15, 10, seed);
            dungeon = gen.grid; startPos = gen.start; goalPos = gen.goal;
            player.y = startPos[0]; player.x = startPos[1];
            // æ¬¡éšã«æ¥ãŸç›´å¾Œã¯æŠ¼ã—ç›´ã—ã‚’è¦æ±‚ã™ã‚‹ï¼ˆignore ã¯é·ç§»å‡¦ç†ã§åˆ¶å¾¡ï¼‰
            stopHold();
            path = []; // éšå±¤é·ç§»æ™‚ã«è»Œè·¡ã‚’ãƒªã‚»ãƒƒãƒˆ
        }

        function resetGame() { level = 1; ap = MAX_AP; }

        // ====== æç”» ======
        function drawRect(x, y, w, h, fill) { ctx.fillStyle = fill; ctx.fillRect(x, y, w, h); }
        function drawText(text, x, y, size = 30, color = '#000', align = 'center') { ctx.fillStyle = color; ctx.font = `${size}px sans-serif`; ctx.textAlign = align; ctx.textBaseline = 'middle'; ctx.fillText(text, x, y); }

        function render() {
            ctx.clearRect(0, 0, SCREEN_W, SCREEN_H);

            if (state === STATE.MENU) {
                drawRect(0, 0, SCREEN_W, SCREEN_H, COLORS.LIGHT);
                drawText('æ¯æ—¥ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³', SCREEN_W / 2, 200, 56, COLORS.BLACK);
                return;
            }

            if (state === STATE.GAMEOVER) {
                drawRect(0, 0, SCREEN_W, SCREEN_H, COLORS.LIGHT);
                drawText('GAME OVER', SCREEN_W / 2, 150, 56, COLORS.RED);
                drawText(`æ½œã£ãŸéšå±¤: ${level}`, SCREEN_W / 2, 250, 24, COLORS.BLACK);
                return;
            }

            drawRect(0, 0, SCREEN_W, SCREEN_H, COLORS.BLACK);

            const startX = Math.max(0, player.x - VIEW);
            const endX = Math.min(DUNGEON_W, player.x + VIEW + 1);
            const startY = Math.max(0, player.y - VIEW);
            const endY = Math.min(DUNGEON_H, player.y + VIEW + 1);

            // ã¾ãšã€ã‚¿ã‚¤ãƒ«ã¨ã‚°ãƒªãƒƒãƒ‰ã‚’ä¸€ç·’ã«æç”»
            ctx.setLineDash([4, 4]);
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const screenX = (x - player.x + VIEW) * TILE;
                    const screenY = (y - player.y + VIEW) * TILE;
                    const tile = dungeon[y][x];

                    // ã‚¿ã‚¤ãƒ«ã‚’å¡—ã‚Šã¤ã¶ã—
                    if (tile === '#') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.DARK);
                    } else if (tile === '.') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.LIGHT);
                    } else if (tile === '+') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.LIGHT);
                        ctx.beginPath();
                        ctx.fillStyle = COLORS.GREEN;
                        ctx.arc(screenX + TILE / 2, screenY + TILE / 2, TILE / 4, 0, Math.PI * 2);
                        ctx.fill();

                        // APå›å¾©é‡ã‚’æç”»
                        const recoveryAmount = apItems[`${y},${x}`];
                        if (recoveryAmount) {
                            ctx.fillStyle = COLORS.WHITE;
                            ctx.font = '10px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(recoveryAmount, screenX + TILE / 2, screenY + TILE / 2);
                        }

                    } else if (tile === 'G') {
                        drawRect(screenX, screenY, TILE, TILE, COLORS.LIGHT);
                        // æ——ã‚’æç”»
                        const flagPoleX = screenX + TILE * 0.7;
                        const flagPoleY = screenY + TILE * 0.2;
                        const flagPoleHeight = TILE * 0.6;
                        const flagWidth = TILE * 0.4;
                        const flagHeight = TILE * 0.3;

                        // æ——ç«¿
                        drawRect(flagPoleX, flagPoleY, 2, flagPoleHeight, COLORS.FLAG_POLE);

                        // æ——
                        ctx.beginPath();
                        ctx.fillStyle = COLORS.FLAG;
                        ctx.moveTo(flagPoleX, flagPoleY);
                        ctx.lineTo(flagPoleX - flagWidth, flagPoleY + flagHeight * 0.5);
                        ctx.lineTo(flagPoleX, flagPoleY + flagHeight);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // ã‚¿ã‚¤ãƒ«ã®è‰²ã«å¿œã˜ã¦ã‚°ãƒªãƒƒãƒ‰ã®è‰²ã‚’å¤‰æ›´
                    if (tile === '#') {
                        ctx.strokeStyle = '#333333'; // å£ç”¨ã®æš—ã„è‰²
                    } else {
                        ctx.strokeStyle = '#e0e0e0'; // é€šè·¯ç”¨ã®æ˜ã‚‹ã„è‰²
                    }
                    ctx.strokeRect(screenX, screenY, TILE, TILE);
                }
            }
            ctx.setLineDash([]); // ç‚¹ç·šè¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ

            // ãã®å¾Œã€è»Œè·¡ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ãã®ä»–ã‚’ä¸Šæ›¸ãæç”»
            drawPath();

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            const px = VIEW * TILE, py = VIEW * TILE;
            drawText('P', px + TILE / 2, py + TILE / 2, 24, COLORS.RED);

            // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹
            if (player.y === startPos[0] && player.x === startPos[1]) {
                drawText('S', px + TILE / 2, py + TILE / 2, 24, COLORS.GREEN);
            } else {
                const sx = (startPos[1] - player.x + VIEW) * TILE;
                const sy = (startPos[0] - player.y + VIEW) * TILE;
                drawText('S', sx + TILE / 2, sy + TILE / 2, 24, COLORS.GREEN);
            }

            // APãƒãƒ¼
            const barW = 120, barH = 16, barX = SCREEN_W - barW - 16, barY = 16;
            drawRect(barX, barY, barW, barH, COLORS.DARK);
            const ratio = Math.max(0, ap) / MAX_AP;
            drawRect(barX, barY, barW * ratio, barH, COLORS.GREEN);
            drawText(`AP: ${ap}/${MAX_AP}`, barX - 56, barY + barH / 2, 13, COLORS.WHITE, 'right');
        }

        // æ–°ã—ã„æç”»é–¢æ•°ï¼šè»Œè·¡
        function drawPath() {
            for (const p of path) {
                const screenX = (p.x - player.x + VIEW) * TILE;
                const screenY = (p.y - player.y + VIEW) * TILE;
                const tile = dungeon[p.y][p.x];
                // ç”»é¢ç¯„å›²å†…ã«ã‚ã‚Œã°æç”»
                if (screenX >= 0 && screenX < SCREEN_W && screenY >= 0 && screenY < SCREEN_H) {
                    // ã‚´ãƒ¼ãƒ«ã¨ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã¯è»Œè·¡ã‚’æç”»ã—ãªã„
                    if (tile !== 'G' && tile !== 'S') {
                        ctx.beginPath();
                        ctx.fillStyle = '#dddddd'; // ã•ã‚‰ã«è–„ã„è‰²ã«å¤‰æ›´
                        ctx.arc(screenX + TILE / 2, screenY + TILE / 2, TILE / 8, 0, Math.PI * 2); // å°ã•ãªç‚¹ã‚’æç”»
                        ctx.fill();
                    }
                }
            }
        }

        // ====== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ======
        function loop() { render(); requestAnimationFrame(loop); }
        loop();

        // åˆæœŸUI
        function showMenu() { changeState(STATE.MENU); }
        showMenu();
    </script>
</body>

</html>